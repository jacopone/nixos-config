---
description: AI Quality DevEnv - Enterprise Development Rules
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.py"
  - "**/*.nix"
  - "**/*.md"
  - "**/*.yaml"
  - "**/*.yml"
  - "**/*.json"
alwaysApply: true
---

# AI Quality DevEnv Rules

You are an expert AI assistant working in an enterprise-grade development environment with comprehensive quality gates and modern tooling.

## Code Quality Standards

### Complexity Management
- Keep cyclomatic complexity below 10 per function
- Maximum function length: 50 lines
- Avoid code duplication above 5% threshold
- Use meaningful variable and function names

### Security First
- Never commit secrets, API keys, or credentials
- Always validate input data
- Use proper error handling with specific error types
- Follow principle of least privilege

### Testing Requirements
- Write tests for all new functionality
- Maintain minimum 75% code coverage
- Use test-driven development when possible
- Include both unit and integration tests

## Technology Stack Integration

### DevEnv Environment
- Respect existing devenv.nix configuration
- Use tools available in the development environment:
  - Node.js 20 for JavaScript/TypeScript
  - Python 3.13 with uv package manager
  - Git hooks for quality enforcement
  - Pre-commit hooks (gitleaks, eslint, ruff, prettier)

### Package Management
- JavaScript/TypeScript: Use npm (configured in devenv)
- Python: Use uv for package management
- System tools: Available via nixpkgs in devenv

### Quality Tools Integration
- **Linting**: ESLint for JS/TS, Ruff for Python
- **Formatting**: Prettier for JS/TS, Black for Python
- **Security**: Gitleaks for secrets, Semgrep for patterns
- **Complexity**: Lizard for complexity analysis
- **Duplication**: JSCPD for clone detection

## AI Workflow Optimization

### Code Generation Guidelines
1. Always consider existing code patterns and conventions
2. Generate code that passes all quality gates
3. Include appropriate error handling and logging
4. Write self-documenting code with clear intent
5. Consider performance implications

### Refactoring Approach
- Maintain backward compatibility unless breaking changes are explicit
- Preserve existing functionality while improving structure
- Update tests when refactoring implementation
- Document significant architectural changes

### Documentation Standards
- Use clear, concise comments for complex business logic
- Document API endpoints with proper TypeScript types
- Include usage examples for public functions
- Maintain README files for project setup and usage

## File Organization

### Project Structure
- Follow established directory conventions
- Keep related files grouped together
- Use consistent naming patterns
- Separate concerns appropriately (UI, business logic, utilities)

### Import/Export Patterns
- Use explicit imports over wildcard imports
- Group imports: external libraries, internal modules, relative imports
- Use barrel exports for cleaner module interfaces
- Prefer named exports over default exports for better refactoring

## Git Workflow Integration

### Commit Standards
- Use Conventional Commits format (enforced by commitizen)
- Write descriptive commit messages explaining "why" not just "what"
- Keep commits atomic and focused on single concerns
- Reference issues/tickets when applicable

### Branch Management
- Work on feature branches, not directly on main/master
- Use descriptive branch names with prefixes (feature/, fix/, chore/)
- Keep branches focused and short-lived
- Ensure all quality gates pass before merging

## Environment-Specific Guidelines

### Development Mode
- Enable debug logging and development tools
- Use development-specific configurations
- Include helpful error messages and stack traces
- Enable hot reloading and fast feedback cycles

### Production Considerations
- Optimize for performance and bundle size
- Remove debug code and console statements
- Use environment variables for configuration
- Implement proper error boundaries and fallbacks

## Performance Guidelines

### JavaScript/TypeScript
- Use modern ES features appropriately
- Implement proper tree shaking
- Optimize bundle size and loading strategies
- Use TypeScript for better development experience

### Python
- Follow PEP 8 style guidelines
- Use type hints for better code clarity
- Implement proper async/await patterns when needed
- Optimize database queries and API calls

### General Performance
- Profile and measure before optimizing
- Cache expensive operations appropriately
- Use lazy loading for non-critical resources
- Monitor and track performance metrics

## Error Handling Patterns

### Frontend Error Handling
- Implement error boundaries for React components
- Provide user-friendly error messages
- Log errors for debugging without exposing sensitive information
- Handle network failures gracefully

### Backend Error Handling
- Use proper HTTP status codes
- Implement structured error responses
- Log errors with appropriate context
- Handle edge cases and validation errors

### Monitoring and Observability
- Include proper logging throughout the application
- Use structured logging formats (JSON)
- Implement health checks and monitoring endpoints
- Track key business and technical metrics

## Accessibility and UX

### Frontend Accessibility
- Use semantic HTML elements
- Implement proper ARIA labels and roles
- Ensure keyboard navigation works properly
- Test with screen readers when possible

### User Experience
- Provide clear feedback for user actions
- Implement loading states for async operations
- Design responsive interfaces for different screen sizes
- Follow established design system patterns

## Special Instructions for AI Agents

### Context Awareness
- Always check existing project configuration files
- Understand the current technology stack and dependencies
- Respect existing code patterns and architectural decisions
- Consider impact on other team members and existing workflows

### Quality Gate Compliance
- All generated code must pass pre-commit hooks
- Ensure proper test coverage for new functionality
- Follow security best practices consistently
- Maintain code complexity within acceptable limits

### Collaboration
- Generate code that integrates well with existing systems
- Provide clear explanations for architectural decisions
- Suggest improvements while respecting existing constraints
- Consider backward compatibility and migration strategies