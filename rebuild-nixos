#!/usr/bin/env bash
set -e

# Parse command line arguments
VERBOSE=false
if [[ "$1" == "--verbose" ]] || [[ "$1" == "-v" ]]; then
    VERBOSE=true
fi

# Setup logging
LOG_DIR="$HOME/.claude/.logs"
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
LOG_FILE="$LOG_DIR/rebuild-$TIMESTAMP.log"

# Colors for output
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Tracking arrays for summary
declare -a WARNINGS=()
declare -a ACTIONS=()
declare -a STATS=()

# Helper functions
log_step() {
    local step_time=$(date +%H:%M:%S)
    echo -e "${BLUE}[$step_time]${NC} $1"
}

log_success() {
    echo -e "${GREEN}âœ…${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}âš ï¸${NC}  $1"
    WARNINGS+=("$1")
}

log_error() {
    echo -e "${RED}âŒ${NC} $1"
}

add_action() {
    ACTIONS+=("$1")
}

add_stat() {
    STATS+=("$1")
}

# Progress indicator with time estimates and status
show_progress() {
    local step_name="$1"
    local pid="$2"
    local history_file="$LOG_DIR/build-times.log"
    local start_time=$(date +%s)

    # Calculate average from last 5 builds if available
    local avg_time=""
    if [ -f "$history_file" ]; then
        avg_time=$(tail -5 "$history_file" | awk '{sum+=$1; count++} END {if(count>0) print int(sum/count)}')
    fi

    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local last_status=""

    while kill -0 "$pid" 2>/dev/null; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))

        # Build progress message
        local msg=$(printf "â±ï¸  %02d:%02d" $mins $secs)

        # Add ETA if we have historical data
        if [ -n "$avg_time" ] && [ "$avg_time" -gt 0 ]; then
            local remaining=$((avg_time - elapsed))
            if [ $remaining -gt 0 ]; then
                local eta_mins=$((remaining / 60))
                local eta_secs=$((remaining % 60))
                msg="$msg | ~%02d:%02d remaining"
                msg=$(printf "$msg" $eta_mins $eta_secs)
            fi
        fi

        # Try to get current status from log file
        if [ -f "$LOG_FILE" ]; then
            local current_status=$(tail -5 "$LOG_FILE" 2>/dev/null | grep -E "building|copying|installing|activating|running|switching|updating" | tail -1)

            if [ -n "$current_status" ]; then
                # Extract package name from nix store path if present
                if echo "$current_status" | grep -q "/nix/store/"; then
                    # Extract just the package name (hash-packagename.drv -> packagename)
                    local pkg_name=$(echo "$current_status" | grep -oP '/nix/store/[a-z0-9]+-\K[^/]+' | head -1 | sed 's/\.drv$//')
                    if [ -n "$pkg_name" ]; then
                        # Get the action (building, copying, etc.)
                        local action=$(echo "$current_status" | grep -oP '^[a-z]+' | head -1)
                        last_status="$action $pkg_name"
                    else
                        last_status=$(echo "$current_status" | cut -c1-60)
                    fi
                else
                    last_status=$(echo "$current_status" | cut -c1-60)
                fi
            fi
        fi

        # Show status if available
        local status_display=""
        if [ -n "$last_status" ]; then
            status_display=" | ${last_status}"
        fi

        # Show spinner and message (allow long lines)
        local spinchar="${spinstr:0:1}"
        spinstr="${spinstr:1}${spinchar}"
        printf "\r$spinchar  $msg$status_display"
        printf "$(tput el)"  # Clear to end of line
        sleep 0.2
    done

    # Clear progress line
    printf "\r$(tput el)"

    # Record build time for future estimates
    local total_time=$(($(date +%s) - start_time))
    echo "$total_time" >> "$history_file"

    # Keep only last 10 builds
    if [ -f "$history_file" ]; then
        tail -10 "$history_file" > "$history_file.tmp"
        mv "$history_file.tmp" "$history_file"
    fi
}

# Start rebuild
echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘            NixOS System Rebuild & Configuration            â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [ "$VERBOSE" = true ]; then
    echo "ğŸ” Verbose mode enabled"
    echo "ğŸ“ Logs: $LOG_FILE"
fi

# Cache sudo credentials early (activation step needs sudo)
echo "ğŸ” This rebuild requires sudo privileges for system activation."
sudo -v || { log_error "Failed to obtain sudo access"; exit 1; }

# Update the flake inputs
log_step "Updating flake inputs..."
if [ "$VERBOSE" = true ]; then
    nix flake update 2>&1 | tee -a "$LOG_FILE"
else
    nix flake update &>"$LOG_FILE"
fi
log_success "Flake inputs updated"
add_action "Updated flake.lock"

# Perform a test build
log_step "Performing test build..."

if [ "$VERBOSE" = true ]; then
    # Verbose mode - show all output
    NEW_CONFIG_PATH=$(NIXPKGS_ALLOW_UNFREE=1 nix build --no-link --print-out-paths --impure .#nixosConfigurations."nixos".config.system.build.toplevel 2>&1 | tee -a "$LOG_FILE" | tail -1)
else
    # Non-verbose mode - show progress indicator
    NIXPKGS_ALLOW_UNFREE=1 nix build --no-link --print-out-paths --impure .#nixosConfigurations."nixos".config.system.build.toplevel > /tmp/nixbuild-output-$$.tmp 2>>"$LOG_FILE" &
    BUILD_PID=$!
    show_progress "test-build" $BUILD_PID
    wait $BUILD_PID
    BUILD_EXIT=$?

    if [ $BUILD_EXIT -ne 0 ]; then
        log_error "Test build failed (exit code: $BUILD_EXIT)"
        echo "Check logs: $LOG_FILE"
        rm -f /tmp/nixbuild-output-$$.tmp
        exit 1
    fi

    NEW_CONFIG_PATH=$(cat /tmp/nixbuild-output-$$.tmp)
    rm -f /tmp/nixbuild-output-$$.tmp
fi

log_success "Test build successful"

# Activate the new configuration
log_step "Activating new configuration..."

if [ "$VERBOSE" = true ]; then
    # Verbose mode - show all output
    if sudo NIXPKGS_ALLOW_UNFREE=1 nixos-rebuild switch --flake . --impure 2>&1 | tee -a "$LOG_FILE"; then
        ACTIVATE_EXIT=0
    else
        ACTIVATE_EXIT=$?
    fi
else
    # Non-verbose mode - show progress indicator
    sudo NIXPKGS_ALLOW_UNFREE=1 nixos-rebuild switch --flake . --impure 2>>"$LOG_FILE" &
    ACTIVATE_PID=$!
    show_progress "activation" $ACTIVATE_PID
    wait $ACTIVATE_PID
    ACTIVATE_EXIT=$?
fi

# Check activation result
if [ $ACTIVATE_EXIT -ne 0 ]; then
    echo ""  # Ensure we're on a new line
    log_error "Activation failed (exit code: $ACTIVATE_EXIT)"
    echo "ğŸ“ Check logs: $LOG_FILE"
    exit 1
fi

echo ""  # Ensure we're on a new line after progress indicator
log_success "Configuration activated"
add_action "Switched to new NixOS configuration"

# Update Claude Code configurations
log_step "Updating Claude Code configurations..."
echo ""

if [ "$VERBOSE" = true ]; then
    # Verbose mode: show all output
    if (cd ~/nixos-config && nix run github:jacopone/claude-nixos-automation#update-all 2>&1 | tee -a "$LOG_FILE"); then
        AUTOMATION_EXIT=0
    else
        AUTOMATION_EXIT=$?
    fi
else
    # Quiet mode: redirect to log, show only summary
    if (cd ~/nixos-config && nix run github:jacopone/claude-nixos-automation#update-all &>"$LOG_FILE.automation"); then
        AUTOMATION_EXIT=0
    else
        AUTOMATION_EXIT=$?
    fi

    # Extract important info from logs
    if [ -f "$LOG_FILE.automation" ]; then
        # Count warnings (grep -c returns 0 count on no matches, exit code 1 is expected)
        WARNING_COUNT=$(grep -c "WARNING:" "$LOG_FILE.automation" 2>/dev/null || true)
        WARNING_COUNT=${WARNING_COUNT:-0}
        # Extract stats (get only the last number from each line to avoid date/time stamps)
        TOOLS_COUNT=$(grep "Total tools documented:" "$LOG_FILE.automation" | tail -1 | grep -oP '\d+' | tail -1 || echo "?")
        QUALITY_TOOLS=$(grep "Quality tools:" "$LOG_FILE.automation" | tail -1 | grep -oP '\d+' | tail -1 || echo "?")

        add_stat "System tools: $TOOLS_COUNT"
        add_stat "Quality tools: $QUALITY_TOOLS"

        if [ "$WARNING_COUNT" -gt 0 ]; then
            log_warning "$WARNING_COUNT warnings during automation (see $LOG_FILE.automation)"
        fi
    fi
fi

if [ $AUTOMATION_EXIT -eq 0 ]; then
    echo ""
    log_success "Claude Code configurations updated"
    add_action "Updated 5 Claude configuration files"

    # Show detailed file update summary
    echo ""
    echo "ğŸ“„ Files updated by automation:"
    echo ""

    # Function to show file status
    show_file_status() {
        local file="$1"
        local description="$2"
        local scope="$3"

        if [ -f "$file" ]; then
            local size=$(du -h "$file" 2>/dev/null | cut -f1)
            local size_bytes=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            local status="âœ“"
            local change_indicator=""

            # Sanity check: 0 bytes = broken
            if [ "$size_bytes" -eq 0 ]; then
                echo -e "  ${RED}âœ— $description (BROKEN - 0 bytes!)${NC}"
                echo "     â†³ $scope"
                return
            fi

            # Check if file is in git and what changed
            if git ls-files --error-unmatch "$file" &>/dev/null 2>&1; then
                if git diff --quiet "$file" 2>/dev/null; then
                    change_indicator=" ${GREEN}unchanged${NC}"
                else
                    # Count lines changed
                    local changes=$(git diff --numstat "$file" 2>/dev/null | awk '{print "+"$1" -"$2}')
                    if [ -n "$changes" ]; then
                        change_indicator=" ${YELLOW}updated${NC} ($changes lines)"
                    else
                        change_indicator=" ${YELLOW}updated${NC}"
                    fi
                fi
            else
                change_indicator=" ${BLUE}untracked${NC}"
            fi

            echo -e "  $status $description [$size]$change_indicator"
            echo "     â†³ $scope"
        else
            echo -e "  ${RED}âœ— $description (FILE NOT FOUND - automation failed!)${NC}"
            echo "     â†³ $scope"
        fi
    }

    # System-wide files (global, all projects)
    show_file_status "$HOME/.claude/CLAUDE.md" \
        "System tools inventory" \
        "Global: AI-aware tool documentation (116 tools)"

    show_file_status "$HOME/.claude/CLAUDE-USER-POLICIES.md" \
        "Your personal policies" \
        "Global: Git commit rules, rebuild restrictions, doc standards"

    echo ""

    # Project-specific files (this project only)
    show_file_status "./CLAUDE.md" \
        "Project context" \
        "Local: Tech stack, commands, architecture (trackable in git)"

    show_file_status "./.claude/settings.local.json" \
        "Security permissions" \
        "Local: Auto-generated allow/deny rules for this project"

    show_file_status "./.claude/CLAUDE.local.md" \
        "Machine state" \
        "Local: Hardware info, services, git branches (gitignored)"

    echo ""
else
    log_warning "Claude automation had issues (check logs)"
fi

echo ""
log_step "Configuration activated. Please test the changes now."
read -p "Are you satisfied with the changes? (y/n) " -n 1 -r
echo

if [[ $REPLY =~ ^[Yy]$ ]]
then
    log_step "Changes accepted. Staging for commit..."
    git add .

    git status

    # Ask for a commit message
    read -p "Enter a commit message for these changes (or leave blank to skip commit): " commit_message

    if [ -n "$commit_message" ]; then
      log_step "Committing changes..."
      git commit -m "$commit_message"
      add_action "Created git commit"
    else
      log_warning "No commit message provided. Skipping commit."
    fi
else
    log_step "Changes rejected. Rolling back to previous configuration..."
    sudo nixos-rebuild switch --rollback
    log_success "Rollback complete"
    exit 0
fi

# Clean up old generations
echo ""
log_step "Listing system generations..."
sudo nixos-rebuild list-generations

read -p "Enter the generations you want to delete (separated by space): " generations_to_delete
if [ -n "$generations_to_delete" ]; then
    log_step "Deleting generations: $generations_to_delete"
    sudo nix-env -p /nix/var/nix/profiles/system --delete-generations $generations_to_delete
    log_success "Selected generations deleted"

    log_step "Running garbage collection..."
    nix-collect-garbage
    log_success "Garbage collection complete"
    add_action "Cleaned up old generations"
else
    log_warning "No generations selected for deletion"
fi

# Disk space analysis for problematic areas
echo ""
log_step "Analyzing disk space for issues..."
declare -a DISK_WARNINGS=()

# Check for oversized log files (>100MB = problematic)
LARGE_LOGS=$(find ~ -maxdepth 4 -name "*.log" -type f -size +100M 2>/dev/null | wc -l)
if [ "$LARGE_LOGS" -gt 0 ]; then
    LARGEST_LOG=$(find ~ -maxdepth 4 -name "*.log" -type f -size +100M 2>/dev/null | xargs du -h 2>/dev/null | sort -rh | head -1)
    DISK_WARNINGS+=("$LARGE_LOGS log file(s) >100MB: ${LARGEST_LOG}")
fi

# Check Claude session files (>5MB = should cleanup)
LARGE_CLAUDE=$(find ~/.claude/projects -name "*.jsonl" -type f -size +5M 2>/dev/null | wc -l)
if [ "$LARGE_CLAUDE" -gt 0 ]; then
    CLAUDE_TOTAL=$(du -sh ~/.claude/projects 2>/dev/null | cut -f1)
    DISK_WARNINGS+=("$LARGE_CLAUDE Claude session(s) >5MB (total: ${CLAUDE_TOTAL})")
fi

# Check for oversized config files (>1MB = investigate)
LARGE_CONFIGS=$(find ~/.config ~/.claude -maxdepth 3 -name "*.json" -type f -size +1M 2>/dev/null | grep -v "IndexedDB\|chrome" | wc -l)
if [ "$LARGE_CONFIGS" -gt 0 ]; then
    DISK_WARNINGS+=("$LARGE_CONFIGS config file(s) >1MB (should be <100KB)")
fi

# Check for old backup files (>1MB)
LARGE_BACKUPS=$(find ~ -maxdepth 3 \( -name "*.bak" -o -name "*.backup" -o -name "*.old" \) -type f -size +1M 2>/dev/null | wc -l)
if [ "$LARGE_BACKUPS" -gt 0 ]; then
    DISK_WARNINGS+=("$LARGE_BACKUPS backup file(s) >1MB (should archive/delete)")
fi

if [ ${#DISK_WARNINGS[@]} -gt 0 ]; then
    echo ""
    echo -e "${YELLOW}âš ï¸  Disk space issues detected (size vs expected):${NC}"
    for warning in "${DISK_WARNINGS[@]}"; do
        echo "   â€¢ $warning"
        log_warning "Disk: $warning"
    done
    echo ""
    echo "ğŸ’¡ Run these commands to investigate:"
    [ "$LARGE_LOGS" -gt 0 ] && echo "   find ~ -maxdepth 4 -name '*.log' -size +100M -exec du -h {} \\; | sort -rh"
    [ "$LARGE_CLAUDE" -gt 0 ] && echo "   find ~/.claude/projects -name '*.jsonl' -size +5M -exec du -h {} \\; | sort -rh"
    [ "$LARGE_CONFIGS" -gt 0 ] && echo "   find ~/.config ~/.claude -maxdepth 3 -name '*.json' -size +1M | grep -v IndexedDB"
    echo ""
fi

# Clean up cache directories
echo ""
log_step "Cache cleanup options..."
echo "Large cache directories detected:"
TOTAL_CACHE_SIZE=0
if [ -d ~/.cache/uv ]; then
    SIZE=$(du -sb ~/.cache/uv 2>/dev/null | cut -f1)
    TOTAL_CACHE_SIZE=$((TOTAL_CACHE_SIZE + SIZE))
    echo "  - UV Python cache: $(du -sh ~/.cache/uv 2>/dev/null | cut -f1)"
fi
if [ -d ~/.cache/google-chrome ]; then
    SIZE=$(du -sb ~/.cache/google-chrome 2>/dev/null | cut -f1)
    TOTAL_CACHE_SIZE=$((TOTAL_CACHE_SIZE + SIZE))
    echo "  - Google Chrome cache: $(du -sh ~/.cache/google-chrome 2>/dev/null | cut -f1)"
fi
if [ -d ~/.cache/yarn ]; then
    SIZE=$(du -sb ~/.cache/yarn 2>/dev/null | cut -f1)
    TOTAL_CACHE_SIZE=$((TOTAL_CACHE_SIZE + SIZE))
    echo "  - Yarn cache: $(du -sh ~/.cache/yarn 2>/dev/null | cut -f1)"
fi
if [ -d ~/.cache/ms-playwright ]; then
    SIZE=$(du -sb ~/.cache/ms-playwright 2>/dev/null | cut -f1)
    TOTAL_CACHE_SIZE=$((TOTAL_CACHE_SIZE + SIZE))
    echo "  - MS Playwright cache: $(du -sh ~/.cache/ms-playwright 2>/dev/null | cut -f1)"
fi
if [ -d ~/.cache/pnpm ]; then
    SIZE=$(du -sb ~/.cache/pnpm 2>/dev/null | cut -f1)
    TOTAL_CACHE_SIZE=$((TOTAL_CACHE_SIZE + SIZE))
    echo "  - PNPM cache: $(du -sh ~/.cache/pnpm 2>/dev/null | cut -f1)"
fi

TOTAL_CACHE_MB=$((TOTAL_CACHE_SIZE / 1024 / 1024))
if [ $TOTAL_CACHE_MB -gt 0 ]; then
    echo "  Total: ${TOTAL_CACHE_MB}MB"
fi

read -p "Clean these cache directories? (y/n) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    log_step "Cleaning cache directories..."
    [ -d ~/.cache/uv ] && rm -rf ~/.cache/uv && echo "  âœ“ UV cache"
    [ -d ~/.cache/google-chrome ] && rm -rf ~/.cache/google-chrome && echo "  âœ“ Chrome cache"
    [ -d ~/.cache/yarn ] && rm -rf ~/.cache/yarn && echo "  âœ“ Yarn cache"
    [ -d ~/.cache/ms-playwright ] && rm -rf ~/.cache/ms-playwright && echo "  âœ“ Playwright cache"
    [ -d ~/.cache/pnpm ] && rm -rf ~/.cache/pnpm && echo "  âœ“ PNPM cache"
    [ -d ~/.cache/chromium ] && rm -rf ~/.cache/chromium && echo "  âœ“ Chromium cache"
    log_success "Cache cleanup complete (freed ~${TOTAL_CACHE_MB}MB)"
    add_action "Cleared ${TOTAL_CACHE_MB}MB of cache"
else
    log_warning "Cache cleanup skipped"
fi

# Clean up large Claude session files
if [ "$LARGE_CLAUDE" -gt 0 ] && [ -d ~/.claude/projects ]; then
    echo ""
    log_step "Found $LARGE_CLAUDE Claude session files >5MB (total: ${CLAUDE_TOTAL})"
    echo "ğŸ’¡ These are old conversation logs that can be safely deleted"
    echo "Options:"
    echo "  1) Delete files >5MB (the ones detected above)"
    echo "  2) Delete files older than 30 days (any size)"
    echo "  3) Delete files >5MB AND older than 30 days"
    echo "  4) Skip cleanup"
    read -p "Choose option (1-4): " -n 1 -r
    echo

    if [[ $REPLY == "1" ]]; then
        # Delete files >5MB regardless of age
        FREED_SPACE=$(find ~/.claude/projects -name "*.jsonl" -size +5M -exec du -sb {} + 2>/dev/null | awk '{sum+=$1} END {print int(sum/1024/1024)}')
        FILE_COUNT=$(find ~/.claude/projects -name "*.jsonl" -size +5M 2>/dev/null | wc -l)
        find ~/.claude/projects -name "*.jsonl" -size +5M -delete 2>/dev/null
        log_success "Deleted $FILE_COUNT large sessions (freed ~${FREED_SPACE}MB)"
        add_action "Cleaned ${FREED_SPACE}MB of Claude sessions"
    elif [[ $REPLY == "2" ]]; then
        # Delete files >30 days regardless of size
        FREED_SPACE=$(find ~/.claude/projects -name "*.jsonl" -mtime +30 -exec du -sb {} + 2>/dev/null | awk '{sum+=$1} END {print int(sum/1024/1024)}')
        FILE_COUNT=$(find ~/.claude/projects -name "*.jsonl" -mtime +30 2>/dev/null | wc -l)
        find ~/.claude/projects -name "*.jsonl" -mtime +30 -delete 2>/dev/null
        log_success "Deleted $FILE_COUNT old sessions (freed ~${FREED_SPACE}MB)"
        add_action "Cleaned ${FREED_SPACE}MB of Claude sessions"
    elif [[ $REPLY == "3" ]]; then
        # Delete files that are both >5MB AND >30 days
        FREED_SPACE=$(find ~/.claude/projects -name "*.jsonl" -size +5M -mtime +30 -exec du -sb {} + 2>/dev/null | awk '{sum+=$1} END {print int(sum/1024/1024)}')
        FILE_COUNT=$(find ~/.claude/projects -name "*.jsonl" -size +5M -mtime +30 2>/dev/null | wc -l)
        find ~/.claude/projects -name "*.jsonl" -size +5M -mtime +30 -delete 2>/dev/null
        log_success "Deleted $FILE_COUNT large+old sessions (freed ~${FREED_SPACE}MB)"
        add_action "Cleaned ${FREED_SPACE}MB of Claude sessions"
    else
        log_warning "Claude session cleanup skipped"
    fi
fi

# Clean up old Claude backup files
if [ -d .backups ]; then
    backup_count=$(find .backups -name "*.backup-*" 2>/dev/null | wc -l)
    if [ "$backup_count" -gt 0 ]; then
        echo ""
        log_step "Found $backup_count Claude backup files in .backups/"
        echo "Options:"
        echo "  1) Delete all backup files (keep only latest version in git)"
        echo "  2) Delete backups older than 7 days"
        echo "  3) Skip cleanup"
        read -p "Choose option (1-3): " -n 1 -r
        echo

        if [[ $REPLY == "1" ]]; then
            # Delete all backup files
            FREED_SPACE=$(find .backups -name "*.backup-*" -exec du -sb {} + 2>/dev/null | awk '{sum+=$1} END {print int(sum/1024/1024)}')
            find .backups -name "*.backup-*" -delete 2>/dev/null
            log_success "Deleted $backup_count backups (freed ~${FREED_SPACE}MB)"
            add_action "Cleaned $backup_count backup files"
        elif [[ $REPLY == "2" ]]; then
            # Delete only old backups
            OLD_COUNT=$(find .backups -name "*.backup-*" -mtime +7 2>/dev/null | wc -l)
            FREED_SPACE=$(find .backups -name "*.backup-*" -mtime +7 -exec du -sb {} + 2>/dev/null | awk '{sum+=$1} END {print int(sum/1024/1024)}')
            find .backups -name "*.backup-*" -mtime +7 -delete 2>/dev/null
            log_success "Deleted $OLD_COUNT old backups (freed ~${FREED_SPACE}MB)"
            add_action "Cleaned $OLD_COUNT old backup files"
        else
            log_warning "Claude backup cleanup skipped"
        fi
    fi
fi

echo ""
read -p "Do you want to push the changes? (y/n) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]
then
    log_step "Pushing to remote..."
    git push
    log_success "Changes pushed to remote"
    add_action "Pushed to git remote"
fi

# Print summary
echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘                    Rebuild Summary                         â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [ ${#ACTIONS[@]} -gt 0 ]; then
    echo "ğŸ“‹ Actions completed:"
    for action in "${ACTIONS[@]}"; do
        echo "   âœ“ $action"
    done
    echo ""
fi

if [ ${#STATS[@]} -gt 0 ]; then
    echo "ğŸ“Š Statistics:"
    for stat in "${STATS[@]}"; do
        echo "   â€¢ $stat"
    done
    echo ""
fi

if [ ${#WARNINGS[@]} -gt 0 ]; then
    echo -e "${YELLOW}âš ï¸  Warnings (review recommended):${NC}"
    for warning in "${WARNINGS[@]}"; do
        echo "   â€¢ $warning"
    done
    echo ""
fi

if [ "$VERBOSE" = false ]; then
    echo "ğŸ“ Detailed logs: $LOG_FILE"
    if [ -f "$LOG_FILE.automation" ]; then
        echo "   Automation logs: $LOG_FILE.automation"
    fi
    echo ""
fi

log_success "NixOS system rebuild and cleanup complete!"
echo ""
